# 리뷰 클립 생성 문제 해결방안

## 📋 문제점 요약

### 1. 핵심 문제들
- **FFmpeg Concat DTS 에러**: Non-monotonous DTS로 인한 타임스탬프 불일치
- **오디오 스트림 누락**: 타이틀 클립에 오디오 트랙 없어서 전체 오디오 손실
- **한글 자막 깨짐**: drawtext 필터 텍스트 이스케이프 문제
- **API 재시작 문제**: 코드 변경 후 gunicorn 재로드 실패

### 2. 증상
- 리뷰 클립이 최종 비디오에 포함되지 않음
- 전체 비디오 길이가 첫 번째 클립만큼만 나옴
- 오디오가 전혀 재생되지 않음
- 한글 자막이 깨져서 표시됨

## 🔧 해결 방안

### 1. Concat → Filter_Complex 교체 (최우선)

#### 현재 문제 코드 (`review_clip_generator.py` 291-320줄)
```python
# ❌ 문제: concat demuxer 사용 (DTS 에러 발생)
async def _concat_clips(self, clips: List[str], output_path: str) -> bool:
    concat_file = tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False)
    for clip in clips:
        concat_file.write(f"file '{clip}'\n")
    
    cmd = [
        'ffmpeg', '-y',
        '-f', 'concat', '-safe', '0', '-i', concat_file.name,
        '-c:v', 'libx264', '-c:a', 'aac',
        output_path
    ]
```

#### 해결 코드
```python
# ✅ 해결: filter_complex 사용 (안정적 병합)
async def _concat_clips_fixed(self, clips: List[str], output_path: str) -> bool:
    """Filter_complex를 사용한 안정적 클립 병합"""
    try:
        if len(clips) == 1:
            # 단일 클립인 경우 복사만
            cmd = ['ffmpeg', '-y', '-i', clips[0], '-c', 'copy', output_path]
        else:
            # 다중 클립 filter_complex 병합
            inputs = []
            for clip in clips:
                inputs.extend(['-i', clip])
            
            # filter_complex 구성
            video_inputs = ''.join([f'[{i}:v]' for i in range(len(clips))])
            audio_inputs = ''.join([f'[{i}:a]' for i in range(len(clips))])
            filter_complex = f"{video_inputs}{audio_inputs}concat=n={len(clips)}:v=1:a=1[outv][outa]"
            
            cmd = [
                'ffmpeg', '-y'
            ] + inputs + [
                '-filter_complex', filter_complex,
                '-map', '[outv]', '-map', '[outa]',
                '-c:v', 'libx264', '-preset', 'medium', '-crf', '16',
                '-c:a', 'aac', '-b:a', '192k', '-ar', '44100', '-ac', '2',
                output_path
            ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            logger.error(f"FFmpeg concat error: {result.stderr}")
            return False
            
        logger.info(f"Successfully concatenated {len(clips)} clips")
        return True
        
    except Exception as e:
        logger.error(f"Error concatenating clips: {e}")
        return False
```

### 2. 오디오 트랙 보장

#### 타이틀 클립 생성 수정 (`review_clip_generator.py` 194-288줄)
```python
# ✅ 모든 클립에 오디오 트랙 보장
async def _create_title_clip(self, output_path: str, title: str, width: int, height: int) -> bool:
    """타이틀 클립 생성 (오디오 트랙 포함)"""
    try:
        drawtext_filter = self._create_drawtext_filter(title, width, height)
        
        cmd = [
            'ffmpeg', '-y',
            # 비디오 입력 (검은 배경)
            '-f', 'lavfi', '-i', f'color=c=black:s={width}x{height}:d=2',
            # 오디오 입력 (무음)
            '-f', 'lavfi', '-i', 'anullsrc=channel_layout=stereo:sample_rate=44100',
            '-vf', drawtext_filter,
            '-c:v', 'libx264', '-preset', 'medium', '-crf', '16',
            '-c:a', 'aac', '-b:a', '192k', '-ar', '44100', '-ac', '2',
            '-shortest',  # 가장 짧은 스트림에 맞춤
            output_path
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        return result.returncode == 0
        
    except Exception as e:
        logger.error(f"Error creating title clip: {e}")
        return False
```

### 3. 한글 자막 이스케이프 개선

#### drawtext 필터 개선 (`review_clip_generator.py` 147-175줄)
```python
def _create_drawtext_filter(self, text: str, width: int, height: int) -> str:
    """개선된 drawtext 필터 생성 (한글 지원)"""
    
    # 텍스트 이스케이프 함수
    def escape_drawtext(text: str) -> str:
        """drawtext용 안전한 텍스트 이스케이프"""
        return (text.replace('\\', '\\\\')
                   .replace(':', '\\:')
                   .replace("'", "\\'")
                   .replace('"', '\\"')
                   .replace('%', '\\%'))
    
    # 폰트 설정
    font_path = "/home/kang/dev_amd/shadowing_maker_xls/font/TmonMonsori.ttf"
    if not os.path.exists(font_path):
        font_path = "/usr/share/fonts/truetype/noto/NotoSansCJK-Bold.ttc"
    
    escaped_text = escape_drawtext(text)
    font_size = 42 if width == 1080 else 32  # 쇼츠용 크게
    
    return (f"drawtext=fontfile='{font_path}'"
            f":text='{escaped_text}'"
            f":fontsize={font_size}"
            f":fontcolor=white"
            f":borderw=2"
            f":bordercolor=black"
            f":x=(w-text_w)/2"
            f":y=(h-text_h)/2")
```

### 4. 개별 클립 생성 개선

#### TTS 클립 생성 안정화
```python
async def _create_individual_clip(self, tts_file: str, korean_text: str, 
                                 output_path: str, width: int, height: int) -> bool:
    """개별 TTS 클립 생성 (오디오 동기화 보장)"""
    try:
        # TTS 오디오 길이 확인
        probe_cmd = [
            'ffprobe', '-v', 'error', '-show_entries', 'format=duration',
            '-of', 'default=noprint_wrappers=1:nokey=1', tts_file
        ]
        result = subprocess.run(probe_cmd, capture_output=True, text=True)
        duration = float(result.stdout.strip())
        
        # 한글 자막 필터
        drawtext_filter = self._create_drawtext_filter(korean_text, width, height)
        
        cmd = [
            'ffmpeg', '-y',
            # 비디오 입력 (검은 배경, TTS 길이만큼)
            '-f', 'lavfi', '-i', f'color=c=black:s={width}x{height}:d={duration}',
            # 오디오 입력 (TTS)
            '-i', tts_file,
            '-vf', drawtext_filter,
            '-c:v', 'libx264', '-preset', 'medium', '-crf', '16',
            '-c:a', 'aac', '-b:a', '192k', '-ar', '44100', '-ac', '2',
            '-shortest',
            output_path
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            logger.error(f"Individual clip creation failed: {result.stderr}")
            return False
            
        logger.info(f"Created individual clip: {output_path} (duration: {duration:.2f}s)")
        return True
        
    except Exception as e:
        logger.error(f"Error creating individual clip: {e}")
        return False
```

## 🚀 구현 단계

### 1단계: _concat_clips 메서드 교체
1. `review_clip_generator.py`의 291-320줄 교체
2. filter_complex 방식으로 구현

### 2단계: 오디오 트랙 보장
1. 타이틀 클립에 무음 오디오 추가
2. 모든 개별 클립에 오디오 스트림 확인

### 3단계: 한글 자막 개선
1. drawtext 이스케이프 함수 개선
2. 폰트 경로 확인 로직 추가

### 4단계: API 재시작 프로세스 개선
```bash
# 완전 재시작 스크립트
#!/bin/bash
echo "Stopping API server..."
pkill -f "gunicorn.*clipping_api"
sleep 2
echo "Starting API server..."
cd /home/kang/dev_amd/shadowing_maker_xls
source venv/bin/activate
gunicorn -w 4 -k uvicorn.workers.UvicornWorker clipping_api:app --bind 0.0.0.0:8081 --daemon
echo "API server restarted"
```

## 🧪 테스트 방법

### 1. 단위 테스트
```python
# test_review_fixed.py
import asyncio
from review_clip_generator import ReviewClipGenerator

async def test_fixed_review():
    generator = ReviewClipGenerator()
    clips_data = [
        {"text_eng": "You will be Hunters.", "text_kor": "너희는 헌터가 될 거야"}
    ]
    
    success = await generator.create_review_clip(
        clips_data, "test_fixed_output.mp4", "스피드 복습", 11
    )
    
    if success:
        print("✅ Fixed review clip creation successful")
        # 비디오 정보 확인
        import subprocess
        result = subprocess.run([
            'ffprobe', '-v', 'error', '-show_streams', 'test_fixed_output.mp4'
        ], capture_output=True, text=True)
        print("Stream info:", result.stdout)
    else:
        print("❌ Fixed review clip creation failed")

if __name__ == "__main__":
    asyncio.run(test_fixed_review())
```

### 2. API 테스트
```bash
curl -X POST http://localhost:8081/api/clip/batch \
  -H "Content-Type: application/json" \
  -d '{
    "media_path": "/mnt/qnap/media_eng/indexed_media/Animation/KPop.Demon.Hunters.2025.1080p.WEBRip.x264.AAC5.1-[YTS.MX].mp4",
    "clips": [
        {
            "start_time": 52.127,
            "end_time": 55.187999999999995,
            "text_eng": "You will be Hunters.",
            "text_kor": "너희는 헌터가 될 거야",
            "keywords": []
        }
    ],
    "study": "review",
    "template_number": 11,
    "title_1": "테스트",
    "title_2": "수정됨"
}'
```

### 3. 결과 검증
```bash
# 생성된 파일 확인
ffprobe -v error -show_streams combined.mp4 | grep codec_type
# 예상 결과: video, audio 둘 다 존재

# 비디오 길이 확인
ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 combined.mp4
# 예상 결과: 원본 클립 + 리뷰 클립 길이 합계

# 오디오 재생 테스트
ffplay combined.mp4  # 오디오가 정상 재생되는지 확인
```

## 📈 기대 효과

1. **DTS 에러 완전 해결**: filter_complex 사용으로 타임스탬프 문제 해결
2. **오디오 보존**: 모든 클립에 오디오 트랙 보장으로 최종 비디오에서 오디오 재생
3. **한글 자막 정상 표시**: 개선된 이스케이프로 한글 깨짐 해결
4. **안정적 병합**: 모든 클립이 최종 비디오에 포함됨

## ⚠️ 주의사항

1. **메모리 사용량 증가**: filter_complex는 concat보다 메모리를 더 사용
2. **처리 시간 증가**: 재인코딩으로 인한 처리 시간 증가
3. **폰트 파일 확인**: 한글 폰트 파일 존재 여부 반드시 확인

## 🔄 배포 절차

1. **백업 생성**: 현재 `review_clip_generator.py` 백업
2. **코드 수정**: 위의 해결 코드로 교체
3. **API 재시작**: 완전 재시작 스크립트 실행
4. **테스트 실행**: 단위 테스트 및 API 테스트
5. **결과 검증**: 비디오 파일 품질 확인

## 📝 체크리스트

- [x] `_concat_clips` 메서드를 filter_complex 방식으로 교체
- [x] 타이틀 클립에 무음 오디오 트랙 추가
- [x] drawtext 이스케이프 함수 개선
- [x] 폰트 파일 경로 확인 로직 추가
- [ ] API 재시작 스크립트 작성
- [x] 단위 테스트 작성 및 실행
- [x] API 통합 테스트 실행
- [x] 결과 비디오 품질 검증

## 📊 구현 결과

### ✅ 성공한 부분

1. **review_clip_generator.py 개선**
   - filter_complex를 사용한 `_concat_clips` 메서드 구현 완료
   - drawtext 이스케이프 함수 개선으로 특수문자 처리 강화
   - 테두리(borderw) 추가로 자막 가독성 향상

2. **단위 테스트 성공**
   ```
   ✅ Review clip created successfully: test_fixed_output.mp4
   📊 Video analysis:
     Video stream: ✅ (h264)
     Audio stream: ✅ (aac)
     Duration: 4.44 seconds
     File size: 59.5 KB
   
   ✅ Multiple clips review created: test_multiple_clips.mp4
     Total duration: 8.13 seconds
   ```

3. **개별 리뷰 클립 생성 정상 작동**
   - TTS 오디오 포함 확인
   - 타이틀 클립에 무음 오디오 추가됨
   - 한글 자막 정상 표시

### ⚠️ 미해결 이슈

1. **API 통합 시 문제**
   - clipping_api.py의 filter_complex 코드가 제대로 작동하지 않음
   - 최종 combined 비디오 생성 시 "moov atom not found" 에러 발생
   - API 재시작이 완전하지 않아 코드 변경사항이 즉시 반영되지 않음

2. **로그 메시지 불일치**
   - 실제로는 filter_complex를 사용하지만 로그에는 여전히 "concat" 메시지 출력

### 🔍 추가 디버깅 필요

1. clipping_api.py의 filter_complex 구현 검증
2. API 완전 재시작 방법 확립
3. 에러 로깅 개선으로 정확한 문제 파악
